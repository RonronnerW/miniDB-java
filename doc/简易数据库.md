参考资料：

[mydb | shinyaのブログ](https://shinya.click/categories/mydb)

[CN-GuoZiyang/MYDB: 一个简单的数据库实现 (github.com)](https://github.com/CN-GuoZiyang/MYDB)

[LiUzHiAn/simpleDB-gitbook: Database Design And Implementation Chineses translation (github.com)](https://github.com/LiUzHiAn/simpleDB-gitbook)

[第14章——事务管理 | SimpleDB (gitbook.io)](https://929910266.gitbook.io/simpledb/part3/ch14)



## 文件管理器

块级接口：

OS维护了块和扇区之间的映射，OS也会给每个磁盘上的每个扇区赋值一个`块号（block number）`; 给定一个块号，操作系统知道实际的扇区地址。

不能直接从磁盘访问块的内容。取而代之的是，必须首先将包含该块的扇区读入`内存页(memory page)`中并从那里进行访问。

页是内存中一个和块同样大小的区域。

**如果一个客户端想要修改一个块中的内容，他必须将这个块先读到页中，然后修改页中的相应字节，然后再将该页写回到磁盘的相应块中。**



文件级接口：

OS提供了另一种，高层次的磁盘接口，被叫做`文件系统（file system）`。一个客户端将一个文件看做是一系列字节，在这个级别上，用户不知道块这概念，相反，客户端可以读/写文件任何位置开始的任意长度的字节流。

Java中的`RandomAccessFile`提供了一个典型的文件系统API。每一个`RandomAccessFile`对象都拥有一个`文件指针（file pointer）`,它指明了下一次文件读写操作时开始的字节位置，这个文件指针可以通过方法`seek()`被显式地赋值，一次`readInt()`或者`writeInt()`的调用将会移动文件指针，移动过的数据就是我们读/写操作的数据。

`readInt()`和`writeInt()`的调用视磁盘被直接获取，隐藏了磁盘块需要先被读到内存页中的细节。



块级支持的好处时操作系统对磁盘块完成的控制权，常用块能被放在中间部分，寻道时间快；并且数据库没有对文件大小限制，数据库文件可以比操作系统文件大。缺点是实现复杂。

文件系统支持每个表都被存放在一个文件中，数据库系统可以使用文件级别的操作来访问记录，这种方式的实现就会简单很多，而且OS将实际的底层磁盘访问隐藏掉，但是这个场景让人不太能接受的原因也有两个：

1. 数据库系统需要知道块的边界在哪里，因而它可以更高效地组织和检索数据。

2. 数据库系统需要管理它自己的页，因为OS提供的I/O缓冲区可能对于数据库的查询来说不是很合适。



一个折中的办法就是数据库系统将所有的数据存储在一个或多个操作系统文件中，但是把这些文件视为raw disks，也就是说，数据库系统通过使用逻辑文件块来访问它的“磁盘”（其实是文件）。OS负责将每个逻辑文件块引用映射到真实的物理磁盘块中，通过`seek()`方法。



文件管理器是数据库中负责与OS进行交互的组件。

数据库将数据存放在几个文件中。对于每个表，会有一个文件；对于每个索引，也会有一个文件；对于日志文件和目录文件也是如此，文件管理器提供了对于这些**文件的块级访问**。

```java
// Blcok.java
public class Block {
    public Block(String fileName, int blkNum);
    public String filename();
    public int number();
}

// Page.java
public class Page {
    public Page();
    public int getInt(int offset);
    public void setInt(int offset,int val);
    
    public int getString(int offset);
    public void setString(int offset,String val);
    
    public void read(Block blk);
    public void write(Block blk);
    public Block append(String fileName);
}

// FileMgr.java
public class FileMgr {
    public FileMgr(String dirname);
    public boolean isNew();
    public int size(String fileName);
}
```

一个`Block`类对象通过给定文件名和逻辑块号唯一标识一个特定的文件块

一个`Page`类对象维持了一个 Block 的内容。方法`setInt()`和`setString()`在页的指定起始位置开始设置了一个新的值，方法`getInt()`和`getString()`检索了指定位置开始的已经存储好的值。方法`read()`,`write()`和`append()`负责实际的磁盘访问。

`FileMgr`类则处理的是实际与OS的交互操作



## 日志管理器

无论什么时候用户对数据库系统进行修改时，数据库系统必须对这些更改进行跟踪，以防需要对这些操作进行撤回。描述一次修改的值被保存在一条`日志记录（log record）`中，而日志记录又被保存在`日志文件（log file）`中，新的日志记录总是被追加在日志文件的末尾。

日志记录步骤：

1. 在内存中分配页。
2. 将日志文件的最后一块读入该页中。
3.     a) 如果页中有空间剩余，则将当前的日志记录追加到已有的所有日志记录之后，并将该页写回到磁盘中。
    b) 如果页中没有空间剩余，则分配一个新的空页，将当前日志记录放到这个新分配的页中，并将该页追加到日志文件的

该算法每追加一条日志记录，需要一次磁盘读操作和一次磁盘写操作。这是非常简单的策略，但不是那么高效。



改进：

日志管理器只需要永久分配一个内存页，来保留上一次日志块中的内容，不必每次从磁盘读；

也不必每次添加日志就将其写回磁盘，页满写回即可。问题：突然宕机页中的日志可能丢失；缓冲管理器满将数据持久化到磁盘时也需要将日志写入磁盘，保持数据一致性。

1. 分配一块永久的内存页来维持日志文件中最后一个块中的日志信息，把这个页称为P.

2. 当有一个新的日志记录到来时：
    a) 如果P中没有空间剩余，则将P写入磁盘并清空P中的内容。
    b) 将新的日志记录添加到P中。

3. 当数据库系统请求一个特殊的日志记录写操作时：
    a) 确定该记录是否驻留在P中。
    b) 如果在，将P写回磁盘。

```java
// LogMgr.java
public class LogMgr {
    public LogMgr(String logfile);

    public int append(Object[] rec);

    public void flush(int lsn);

    public Iterator<BasicLogRecord> iterator();

}

// BasicLogRecord.java
public class BasicLogRecord {

    public BasicLogRecord(Page logPage, int pos);

    public int nextInt();

    public String nextString();
}
```

LSN是用来标识一条日志记录的，例如，一个典型的LSN可能包含当前块号以及当前日志记录在该块的起始位置。然而，这里只用一个块的块号来唯一标识当前日志记录，也就是说，一个块中的所有日志记录会有相同的LSN，这种简化丝毫不会降低程序的正确性，但的确会降低那么一些些的效率。

方法`flush()`会比较当前的块号和指定的LSN，如果指定的LSN更小，那对应的日志记录肯定已经被写回到了磁盘中；否则，`logPage`会执行一次磁盘写操作。

`append()`方法则会先一下计算当前待写入的日志记录需要用多少个字节来存储，从而确定当前日志页是否能够容纳下。如果容纳不下，它会首先将当前页中的内容写回到磁盘，然后调用一次`appendNewBlock()`方法来清除当前日志页，最后将新的日志记录写进去。

一旦`append()`方法确保当前日志记录可以可以装进当前的日志页，那么它会依次将日志记录中的每个值都装到日志页中，最后执行`finalizeRecord()`方法。该方法会在新的记录后面再写一个int整数，用来标识上一条日志记录的其实位置，这样一来，页中的所有记录就像是一个倒着的链表一样。页的第一个int，标识的是这个链表的头指针——在这里，因为链表是逆序的，也就是最后一条日志记录的起始位置。

![](.\img\log.png)



## 缓冲管理器

缓冲管理器负责管理那些持有数据的内存页，缓冲管理器维持着一系列固定数量的内存页，被称为`缓冲池（buffer pool)`

为了访问一个块，一个客户端会按照以下的协议与缓冲管理器进行交互：

1. 客户端请求缓冲管理器从缓冲池中`固定(pin)`一个页，用来维持块中的内容。
2. 客户端按照相应的逻辑，操作页中的内容。
3. 当客户端完成页的操作后，它告诉缓冲管理器`取消固定(unpin)`那个页。

当一个客户端正在pinning一个页时，我们称这个页是被`固定(pinned)`的状态；否则称这个页为`非固定(unpinned)`的状态。当一个页被客户端固定了后，缓冲管理器有义务确保该页一直可用；相反，一旦取消固定某个页，则允许缓冲区管理器将其分配给另一个块。

> 一个被固定的缓冲页的使用者为客户端。 一个没被固定的缓冲页的使用者为缓冲管理器。

当一个客户端请求缓冲管理器为某个块而固定一个页时，缓冲管理器将会遇到以下可能的4种情况之一：

1. 块中的内容已经在缓存中，而且：

   1. 这个页是被固定的

   2. 这个页没被固定

2. 块中的内容不在缓存中，而且：
   1. 缓冲池中至少有一个没被固定的页
   2. 缓冲池中所有的页都被固定了



### 缓冲区

缓冲池中的每个页都有自己的缓冲区。

任意一个想要使用块的客户端，将会被简单地带到缓存页中，然后客户端可以实现无需任何磁盘访问，从而读取或修改数据的操作。缓冲区需要将修改的页写回磁盘的原因只有两个：

1. 要么缓冲区因为固定另外一个页面而被替换

2. 要么恢复管理器需要将内容写回到磁盘，从而防止可能的系统崩溃发生。



一个缓冲页对象追踪了关于这个页的以下4种信息：

1. 一个赋值到内容到该页上的磁盘块引用。假如没有块被赋值，这个值为null。

2. 这个缓冲页被固定的次数。每固定一次，该值加1；每取消固定一次，该值减1。

3. 一个表示当前缓冲页内容是否被修改的整数。-1表示没被修改，否则标识的是使得作出该修改的事务标识符。

4. 日志信息。如果当前缓冲页被修改，于是会持有一个最近的日志记录的序列化，即`LSN`,LSN是非负的。如果一个客户端调用`Buffer`类的`setInt()`或`setString()`方法时，传入了一个负的LSN，那意味着将不生成一条对应这次修改的日志记录。

`flush()`方法确保缓冲区的页中的内容和所赋值的块中的内容一致。如果缓冲区没被修改，那么这个方法什么也不干；如果被修改过，那么这个方法会先调用`LogMgr.flush()`方法确保对应的日志记录被写到文件上，随后再将缓冲页中的内容写回到磁盘上。

`assignToBlock()`和`assignToNew()`方法将缓冲区和一个磁盘块联系起来。在这两个方法中，缓冲区首先都会被flush一下，从而确保之前块的任何修改都被持久化到磁盘上了。`assignToBlock()`方法通过把块中的内容读入到缓冲页中，从而实现缓冲区和块的联系；而`assignToBlock()`方法则通过执行页格式化操作，然后把这个页追加到文件尾部，并且将追加的块和当前缓冲页联系起来。



### 缓存置换策略

缓冲池中的页最开始是没被分配的。一旦一个固定请求到来，缓冲管理器通过将被请求的块赋值到未分配的页上，从而填充缓冲池。一旦所有的页都被分配，缓冲管理器将会开始替换页，缓冲管理器可以选择缓冲池中的任意页，前提是该页面未被固定。如果缓冲管理器需要替换一个页，而所有的缓存页又被固定了，那么这个请求的客户端必须等待。

**Naive 策略**

最简单的替换策略是依次遍历缓冲池，替换找到的第一个未固定的缓冲区。

**FIFO 策略**

最早被固定的页面会最早被替换。FIFO策略的替换策略可以以两种方式来实现。

第一种方式就是在每个缓冲页中维持一个当前页被替换的时间，替换算法到时候可以扫描一遍缓冲池，在那些没被固定的页中，选择最早的页来换掉。

第二种更加高效的实现方法是，缓冲管理器维持一个指向缓冲区的指针列表，而这个列表又是以置换的时间为顺序进行排序的。置换算法会搜索该指针列表，列表中第一个没被固定的页将会被置换，然后该指针移动到列表的尾部。

**LRU 策略**

选择最近一段时间内，被取消固定次数最少的未固定缓冲区

FIFO的两种实现策略也可以适用于LRU算法中，唯一的变化就是，在LRU策略实现的时候，每次取消固定页面时（而不是在替换页面时），缓冲区管理器必须更新时间戳（对于第一种实现策略）或更新列表（对于第二种实现策略）。

**Clock 策略**

以上一次置换的页为起点开始扫描，选择第一个找到的未被固定的页



```java
// Buffer.java
public class Buffer {

    public int getInt(int offset);
    public String getString(int offset);
    public void setInt(int offset,int val,int txNum,int LSN);
    public void setString(int offset,String val,int txNum,int LSN);
    public Block block();
}


// BufferMgr.java
public class BufferMgr {

    public BufferMgr(int numBuffers);
    public Buffer pin(Block blk);
    public void unpin(Buffer buffer);
    public Buffer pinNew(String fileName, PageFormatter pageFormatter);
    public void  flushAll(int txNum);
    public int available();
}

// PageFormatter.java
interface PageFormatter {
    public void format(Page p);
}
}
```

一个客户端可以读取已固定的缓冲区中的具体内容，通过的是调用`getInt()`和`getString()`方法。

通过调用缓冲区的`setInt()`和`setString()`方法，来修改块的值。在修改之前，客户端必须首先将合适的日志记录写到日志文件中，并且获得其LSN，缓冲区会保存这些值，并在需要将日志记录强制写回到磁盘时使用它们。



方法`pin()`的功能是将指定块的内容赋值到一个缓冲区上，这个算法有两部分。第一部分，`findExistingBuffer()`，这个方法会尝试去寻找一个已经被赋值为指定块内容的缓冲区，如果找到了,就返回这个缓冲区；第二部分，`chooseUnpinnedBuffer()`方法，使用Naive策略来准备置换一个未固定的页，随后再使用那个缓冲区的`assignToBlock()`方法，把块的内容赋值到缓冲区上。注意，如果找不到一个没被固定的缓冲区将进入等待队列。

方法`pinNew()`的功能是将缓冲区上的内容追加到一个指定的文件尾部，这个方法和`pin()`方法很类似，但是这个方法会直接调用`chooseUnpinnedBuffer()`方法。然后再调用`assignToNew()`方法，会相应的创建一个新块。注意，如果找不到一个没被固定的缓冲区将进入等待队列，那么该方法返回null。



## 事务管理

### 恢复管理器

负责读取并处理日志信息，包括写日志记录，回滚事务，数据库崩溃后恢复。

#### 日志记录

日志记录有四种基本类型：`开始日志记录（start log record）`，`提交日志记录（commit log record）`，`回滚日志记录（rollback log record）`和`更新日志记录（update log record）`

三种可以引发日志记录写入的事件为：

1. 事务开始时的开始日志记录

2. 事务完成时的提交日志记录或回滚日志记录

3. 当事务修改某个值时的修改日志记录

每条日志记录都包含有关该记录的类型描述（START，SETINT，SETSTRING，COMMIT或ROLLBACK）及其事务的ID。更新日志记录包含五项其他内容：修改的文件名、块号、进行修改的位置的偏移量、该偏移量处的旧值，以及该偏移量处的新值。

#### 回滚

```
事务T的回滚算法

1. 把最近的日志记录作为当前日志记录;
2. while(当前日志记录 != 事务T的开始日志记录){
        if(当前日志记录 == 事务T的更新日志记录)
            在指定位置写入修改前的old value;
        else
           当前日志记录 = 上一条日志记录; 
    }
3. 追加一条回滚日志记录到日志文件;
```

为什么此算法从日志文件末尾开始向前读取，而不是从开始位置向后读取？有两个原因：

- 第一个原因是，日志文件的开头部分一般已经完成的事务的日志记录，而且这些事务一般离现在都很久远，我们正在寻找的日志记录最有可能在日志的末尾，因此从末尾读取效率更高；
- 第二个更重要的原因是要确保正确性。假设某个位置的值被修改多次，然后日志文件中将有对应该位置的多个日志记录，每个都有不同的值。 要恢复的值应该来自这些日志记录中最早的那个，如果我们以相反的顺序处理日志记录，则刚好对应这种情况发生。

#### 恢复

在数据库恢复的过程中，由于未提交事务而带来的修改必须被undo，由于已经提交事务而带来的修改（即页中的内容没有flush到磁盘上去）必须redo。

```
恢复算法

// undo 步骤 （负责处理那些未提交的事务，这些事务有可能已经将数据flush到磁盘上）
1. 对于每条日志记录(从日志文件尾部一直往前读){
    if(当前日志记录 instanceof 提交日志记录)
        将该事务添加到提交事务列表中
    if(当前日志记录 instanceof 回滚日志记录)
        将该事务添加到回滚事务列表中
    if( (当前日志记录 instanceof 更新日志记录) && 
        !提交事务列表.contains(当前事务) && 
        !回滚事务列表.contains(当前事务)  )
        在指定的位置的数据恢复成old value
}
     
// redo 步骤 （负责处理那些已经提交了，但未flush数据到磁盘的事务）
2. 对于每条日志记录(从日志文件头部一直往后读){
    if( (当前日志记录 instanceof 更新日志记录) && 
        提交事务列表.contains(当前事务) )
        在指定的位置的数据恢复成new value
}
```



**undo-only**

如果恢复管理器确定所有提交的修改都已写入磁盘，则可以省略阶段2。恢复管理器可以通过在将提交记录写入日志之前将缓冲区强制到磁盘来达到这一目的。

```
Undo-only恢复下的事务提交算法

1. 将事务修改的页中的内容flush到磁盘上。
2. 写一条commit log record。
3. 将包含日志记录的日志页flush到日志文件上。
```

Undo-only恢复的速度更快，因为仅需要一次遍历日志文件，而不是两次。日志也较小，因为更新日志记录不再需要包含新的修改值；但另一方面，提交操作会慢很多，因为它必须刷新修改后的缓冲区。如果我们假设系统崩溃很少发生，那么Undo-redo恢复就是最好的选择。事务不仅提交速度更快，而且由于延迟了缓冲区刷新，因此总的磁盘写次数应该更少。

**redo-only**

如果恢复管理器确定所有未提交事务对应修改的缓冲区内容尚未写入磁盘，则可以省略阶段1。恢复管理器可以通过使每个事务保持其缓冲区固定，直到事务完成，来实现这一目的。因为固定的缓冲区将不会被选择替换，因此其内容也不会被flush到磁盘上。但是，当事务回滚时，我们需要“擦除”该事务对缓冲区做出的修改。

```
redo-only恢复下的事务回滚算法

对于每个事务修改的缓冲区：
    a) 将缓冲区标记为未分配的。（在SimpleD中，将缓冲区的块号设置为-1即可）
    b) 将缓冲区标记为未修改的。
    c) 将缓冲区取消固定。
```

redo-only恢复比Undo-redo恢复执行要快，因为可以忽略未提交的事务。但是，它要求为每个事务保证有1个缓冲区，用来固定它将修改的每个块，这增加了系统中缓冲区的争用。在大型数据库中，此争用会严重影响所有事务的性能，这使得redo-only恢复是一个冒险的选择。
